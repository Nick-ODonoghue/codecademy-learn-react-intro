<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Learn React: Introduction - Codecademy | NickOD.xyz</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="reset.css">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  <main class="wrapper">

    <h1>Codecademy - Learn React: Introduction</h1>
    <p>Notes taken while going through the <a
        href="https://www.codecademy.com/learn/learn-react-introduction">Codecademy Learn React: Introduction
        course</a>
    </p>

    <h2>Intro to JSX</h2>

    <section>
      <h3>Why React</h3>
      <ul>
        <li>React is known for its speed and responsiveness, allowing apps to handle complex updates efficiently.</li>
        <li>React promotes modularity by breaking down code into smaller, reusable components, improving
          maintainability.</li>
        <li>It excels in scalability, making it suitable for large programs that involve frequent data changes.</li>
        <li>React is flexible and can be used for various projects beyond web app development, opening up opportunities
          for exploration.</li>
        <li>React's popularity in the industry makes learning and understanding it valuable, enhancing employability
          prospects.</li>
      </ul>
    </section>

    <section>
      <h3>What is JSX?</h3>
      <ul>
        <li>JSX is a syntax extension for JavaScript used with React.</li>
        <li>JSX code resembles HTML and is written within JavaScript files.</li>
        <img src="./assests/images/jsxCode.jpg" alt="jsx code">
        <li>JSX is not valid JavaScript, so it needs to be compiled before it can be understood by web browsers.</li>
        <li>A JSX compiler translates JSX code into regular JavaScript.</li>
        <li>The compilation process ensures that the JavaScript file containing JSX is compatible with web browsers.
        </li>
      </ul>
    </section>

    <section>
      <h3>JSX Elements</h3>
      <ul>
        <li>A JSX element is the basic unit of JSX syntax.</li>
        <li>JSX elements resemble HTML syntax.</li>
        <img src="./assests/images/jsxElement.jpg" alt="jsx element">
        <li>JSX elements are typically written within JavaScript files.</li>
        <li>JSX elements can be similar to their HTML counterparts but are found within JavaScript files instead of HTML
          files.</li>
      </ul>
    </section>

    <section>
      <h3>JSX Elements & their Surroundings</h3>
      <ul>
        <li>JSX elements are treated as JavaScript expressions and can be used anywhere JavaScript expressions are
          allowed.</li>
        <li>JSX elements can be saved in variables:</li>
        <img src="./assests/images/jsxElementVariable.jpg" alt="jsx element saved to a variable">
        <li>JSX elements can be stored in objects or arrays:</li>
        <img src="./assests/images/jsxElementObject.jpg" alt="jsx elements stored in an object">
        <li>JSX elements offer flexibility and can be manipulated and used like any other JavaScript expression.</li>
      </ul>
    </section>

    <section>
      <h3>Attributes in JSX</h3>
      <ul>
        <li>JSX elements can have attributes similar to HTML elements.</li>
        <li>JSX attributes follow an HTML-like syntax: name="value" format.</li>
        <img src="./assests/images/jsxAttributesSyntax.jpg" alt="jsx attribute syntax">
        <li>Attribute values are typically wrapped in quotes.</li>
        <img src="./assests/images/jsxAttributeExample.jpg" alt="jsx attribute example">
        <li>A single JSX element can have many attributes, just like in HTML:</li>
        <img src="./assests/images/jsxAttributesExample.jpg" alt="jsx with many attributes">
      </ul>
    </section>

    <section>
      <h3>Nested JSX</h3>
      <ul>
        <li>JSX elements can be nested inside other JSX elements, similar to HTML.</li>
        <img src="./assests/images/nestedjsx.jpg" alt="nested jsx">
        <li>For better readability, you can use line breaks and indentation, similar to HTML:</li>
        <img src="./assests/images/nestedjsxIndented.jpg" alt="indented nested jsx">
        <li>If a JSX expression spans multiple lines, it should be wrapped in parentheses.</li>
        <img src="./assests/images/nestedjsxWrapped.jpg" alt="wrapped multi line jsx">
        <li>Nested JSX expressions can be assigned to variables or passed to functions like non-nested JSX expressions:
        </li>
        <img src="./assests/images/nestedjsxWrappedVariable.jpg" alt="nested jsx variable">
      </ul>
    </section>

    <section>
      <h3>JSX Outer Elements</h3>
      <ul>
        <li>A JSX expression must have exactly one outermost element.</li>
        <li>The opening tag of the JSX expression and the closing tag must belong to the same JSX element.</li>
        <li>The following would work fine:</li>
        <img src="./assests/images/jsxOuterElementCorrect.jpg" alt="jsx outer element example">
        <li>But this would not work and would throw errors:</li>
        <img src="./assests/images/jsxOuterElementIncorrect.jpg" alt="jsx element with an error">
        <li>If you encounter an error due to multiple outer elements, the solution is to wrap the JSX expression in a
          <div> element or any other suitable parent element.
        </li>
      </ul>
    </section>

    <section>
      <h3>Rendering JSX Explained</h3>
      <ul>
        <li>Rendering in React involves specifying what content to render and where to place that content.</li>
        <li>The render() method is used to render JSX expressions.</li>
        <img src="./assests/images/jsxRendering.jpg" alt="jsx rendering">
        <li>To determine where to place the content, the first line uses the getElementById() method of the document
          object to get the HTML element with the specified ID ('app' in this case) and stores it in the container
          variable.</li>
        <img src="./assests/images/jsxRenderingFirstLine.jpg" alt="jsx rendering first line">
        <li>The createRoot() function from the react-dom/client library is used to create a React root from the
          container, and the resulting root is stored in the root variable. This establishes the target location for
          rendering the content.</li>
        <img src="./assests/images/jsxRenderingSecondLine.jpg" alt="jsx rendering second line">
        <li>Finally, the render() method of the root object is called, passing in the JSX expression (<h1>Hello world
          </h1>) as the content to be rendered. This triggers the rendering process, displaying the specified content in
          the designated location.</li>
        <img src="./assests/images/jsxRenderingThirdLine.jpg" alt="jsx rendering third line">
      </ul>
    </section>

    <section>
      <h3>Passing a Variable to render()</h3>
      <ul>
        <li>The render() method in React can accept a variable as its argument, as long as the variable evaluates to a
          JSX expression.</li>
        <img src="./assests/images/renderVariable.jpg" alt="passing a veriable to render">
        <li>In the example, a JSX expression representing a to-do list is saved in the toDoList variable.</li>
        <li>The createRoot() function is used to create a React root from the container element.</li>
        <li>The render() method of the root object is called, and the toDoList variable is passed as the argument. The
          JSX expression stored in toDoList will be evaluated and rendered in the designated location.</li>
      </ul>
    </section>

    <section>
      <h3></h3>
      <ul>
        <li>The Virtual DOM</li>
        <li>When using the render() method in React, it only updates the DOM elements that have changed.</li>
        <li>If the exact same JSX expression is rendered twice in a row, the second render will not make any changes to
          the DOM.</li>
        <img src="./assests/images/virtualDOM.jpg" alt="duplicate root render">
        <li>React achieves this efficient update process by utilizing the concept of the Virtual DOM.</li>
        <li>The Virtual DOM is a lightweight representation of the actual DOM.</li>
        <li>When changes are made to the React components, React compares the Virtual DOM with the previous version to
          identify the specific elements that need to be updated.</li>
        <li>Only the necessary changes are then applied to the real DOM, resulting in better performance and efficiency.
        </li>
        <li>The use of the Virtual DOM is one of the key factors contributing to React's success in efficiently updating
          and rendering UI components.</li>
      </ul>
    </section>

    <section>
      <h3>Review: Intro to JSX</h3>
      <ul>
        <li>React is a modular, scalable, flexible, and popular front-end framework.</li>
        <li>JSX is a syntax extension for JavaScript which allows us to treat HTML as expressions.</li>
        <li>They can be stored in variables, objects, arrays, and more!</li>
        <li>JSX elements can have attributes and be nested within each other, just like in HTML.</li>
        <li>JSX must have exactly one outer element, and other elements can be nested inside.</li>
        <li>createRoot() from react-dom/client can be used to create a React root at the specified DOM element.</li>
        <li>A React root’s render() method can be used to render JSX on the screen.</li>
        <li>A React root’s render() method only updates DOM elements that have changed using the virtual DOM.</li>
      </ul>
      <p>
        <a href="https://www.codecademy.com/learn/learn-react-introduction/modules/react-101-jsx-u/cheatsheet">Codecademy
          -
          JSX Cheatsheet</a>
      </p>
    </section>

    <h2>React: The Virtual DOM</h2>

    <section>
      <h3>The Virtual DOM Explained</h3>
      <ul>
        <li>DOM manipulation, the process of updating the web page's structure, is slower compared to other JavaScript
          operations.</li>
        <li>Many JavaScript frameworks tend to update the DOM more than necessary, resulting in inefficiencies.</li>
        <li>React addresses this issue with the concept of the Virtual DOM.</li>
        <li>In React, there is a corresponding "virtual DOM object" for every real DOM object. The virtual DOM object is
          a lightweight copy of the real DOM object.</li>
        <li>The virtual DOM object has the same properties as the real DOM object but lacks the power to directly change
          what's displayed on the screen.</li>
        <li>When a JSX element is rendered, every virtual DOM object is updated.</li>
        <li>Updating the virtual DOM is much faster because it doesn't involve drawing anything on the screen. It's like
          editing a blueprint instead of moving rooms in a house.</li>
        <li>After updating the virtual DOM, React compares it with a virtual DOM snapshot taken before the update. This
          process is called "diffing."</li>
        <li>By comparing the new virtual DOM with the pre-update version, React determines which virtual DOM objects
          have changed.</li>
        <li>React then updates only the changed objects on the real DOM, rather than rebuilding the entire DOM. This
          selective updating is efficient.</li>
        <li>React's ability to update only the necessary parts of the DOM contributes to its reputation for performance
          and efficiency.</li>
      </ul>
    </section>

    <h2>Advanced JSX</h2>

    <section>
      <h2>class vs className</h2>
      <ul>
        <li>In HTML, the attribute name for defining the CSS class of an element is "class".</li>
        <img src="./assests/images/htmlClassExample.jpg" alt="html class example">
        <li>However, in JSX, you cannot use the attribute name "class" because it is a reserved word in JavaScript.</li>
        <li>Instead, you need to use "className" as the attribute name in JSX.</li>
        <img src="./assests/images/jsxClassNameExample.jpg" alt="jsx classname example">
        <li>JSX is translated into JavaScript, and using "className" ensures compatibility and avoids conflicts with the
          reserved word "class".</li>
        <li>When the JSX is rendered, the "className" attributes are automatically translated and rendered as "class"
          attributes in the resulting HTML.</li>
      </ul>
    </section>

    <section>
      <h2>Self-Closing Tags</h2>
      <ul>
        <li>In HTML, some elements like <br> and <input> can be written with or without a closing slash before the final
          angle bracket.</li>
        <img src="./assests/images/htmlSelfClosingTags.jpg" alt="html self-closing tags">
        <li>However, in JSX, it is mandatory to include the closing slash in self-closing tags. Forgetting to include
          the slash will result in an error.</li>
        <img src="./assests/images/jsxSelfClosingTags.jpg" alt="jsx self-closing tags">
        <li>Remember to always use the closing slash in self-closing tags in JSX to ensure proper syntax and avoid
          errors.</li>
      </ul>
    </section>

    <section>
      <h2>Curly Braces in JSX</h2>
      <ul>
        <li>When you write code in between the tags of a JSX element, it is treated as JSX, not regular JavaScript.</li>
        <li>To indicate that you want a code snippet to be treated as regular JavaScript within JSX, you need to wrap it
          in curly braces {}.</li>
        <img src="./assests/images/curlyBraces.jpg" alt="curly braces">
        <li>By using curly braces, you can execute JavaScript expressions and statements within JSX.</li>
        </li>
        <li>Curly braces allow you to inject dynamic and executable JavaScript code within JSX elements.</li>
      </ul>
    </section>

    <section>
      <h2>Variables in JSX</h2>
      <ul>
        <li>When you inject JavaScript into JSX, the JavaScript code has access to variables declared in the same
          environment.</li>
        <li>You can access variables while inside a JSX expression, even if those variables were declared outside the
          JSX code block.</li>
        <img src="./assests/images/variablesInJSX.jpg" alt="variables in jsx">
        <li>The value of the variable will be evaluated and inserted into the JSX during rendering.</li>
      </ul>
    </section>

    <section>
      <h2>Variable Attributes in JSX</h2>
      <ul>
        <li>Variables can be used to set attributes in JSX by wrapping them in curly braces {}.</li>
        <img src="./assests/images/variableAttributes.jpg" alt="variable attributes">
        <li>Each attribute can be set on a separate line for better readability, especially when dealing with multiple
          attributes.</li>
        <li>Object properties can also be used to set attributes. You can access the desired property using dot notation
          or square brackets.</li>
        <img src="./assests/images/objectVariableAttributes.jpg" alt="object variable attributes">
        <li>By using variables and object properties, you can make your JSX code more dynamic and reusable, allowing for
          easy updates and customization.</li>
      </ul>
    </section>

    <section>
      <h2>Event Listeners in JSX</h2>
      <ul>
        <li>JSX elements can have event listeners, similar to HTML elements.</li>
        <li>Event listeners in JSX are created by using a special attribute on the JSX element.</li>
        <li>The event listener attribute's name should follow the pattern of "on" + event type, such as onClick or
          onMouseOver.</li>
        <li>The value of an event listener attribute should be a function.</li>
        <img src="./assests/images/eventListenerJSX.jpg" alt="event listener in jsx">
        <li>The function clickAlert should be defined elsewhere in the code.</li>
        <img src="./assests/images/eventListenersFunction.jpg" alt="the event listeners function code">
        <li>In JSX, event listener names are written in camelCase, such as onClick or onMouseOver.</li>
        <li>In HTML, event listener names are written in all lowercase, such as onclick or onmouseover.</li>
      </ul>
    </section>

    <section>
      <h2>JSX Conditionals: If Statements that do Work</h2>
      <ul>
        <li>In JSX, you cannot directly inject an if statement.</li>
        <li>One way to express conditionals in JSX is to write the if statement outside of the JSX code.</li>
        <img src="./assests/images/jsxConditionals.jpg" alt="jsx conditionals">
        <li>The if statement can be used to conditionally determine which JSX code to render.</li>
        <li>By placing the if statement on the outside, there is no need for JavaScript injection within JSX tags.</li>
        <li>This approach is a common way to handle conditionals in JSX.</li>
      </ul>
    </section>

    <section>
      <h2>JSX Conditionals: The Ternary Operator</h2>
      <ul>
        <li>The ternary operator, written as x ? y : z, is a compact way to write conditionals in JSX.</li>
        <li>It works the same way in React as it does in regular JavaScript.</li>
        <li>The ternary operator is commonly used in JSX expressions.</li>
        <li>Inside the curly braces of a JSX expression, you can use the ternary operator to conditionally render
          different content.</li>
        <li>The expression before the question mark (?) is evaluated and determines whether it is truthy or falsy.</li>
        <li>If the expression is truthy, the value before the colon (:) is returned. Otherwise, the value after the
          colon is returned.</li>
        <li>The ternary operator is often used to conditionally render different JSX elements or to assign different
          values to variables based on a condition.</li>
        <img src="./assests/images/ternaryOperator.jpg" alt="ternary operator">
        <li>In the provided example, the ternary operator is used to conditionally set the value of the headline
          variable based on the comparison between age and drinkingAge.</li>
        <li></li>
        <li></li>
      </ul>
    </section>

    <section>
      <h2>JSX Conditionals: &&</h2>
      <ul>
        <li>The && operator is another way to write conditionals in JSX, commonly used for rendering content
          conditionally.</li>
        <li>It works similarly to the logical AND operator in JavaScript.</li>
        <img src="./assests/images/jsxConditionalsAndOperator.jpg" alt="jsx conditionals && operator">
        <li>If the expression on the left of the && is true, the JSX on the right of the && will be rendered.</li>
        <li>If the expression on the left is false, the JSX on the right will be ignored and not rendered.</li>
        <li>The && operator is useful for conditionals that should sometimes perform an action and other times do
          nothing at all.</li>
        <li>It can help simplify conditional rendering by avoiding the need for additional if statements or ternary
          operators.</li>
        <li>In the provided example, the && operator is used to conditionally render different list items based on the
          values of baby and age.</li>
        <li>The list item containing "Pizza" will be rendered if baby is false.</li>
        <li>The list items containing "Brussels Sprouts", "Oysters", and "Grappa" will be rendered based on the
          different age conditions.</li>
        <li>Only the list items corresponding to true expressions will be included in the final JSX output.</li>
      </ul>
    </section>

    <section>
      <h2>.map in JSX</h2>
      <ul>
        <li>The .map() method is commonly used in React to create a list of JSX elements efficiently.</li>
        <li>When you have an array and want to transform each element into JSX, you can use .map() to iterate over the
          array and return a new array of JSX elements.</li>
        <img src="./assests/images/mapInJSX.jpg" alt="map in jsx">
        <li>In the provided example, the array strings contains a list of strings.</li>
        <li>By calling .map() on strings, we create a new array listItems where each string is transformed into an
        <li> element.</li>
        <li>The arrow function is used as the transformation function in the .map() call. It takes each string as input
          and returns the corresponding JSX
        <li> element.</li>
        <li>The {listItems} expression is used to include the array of JSX elements in the JSX code. It will be
          evaluated to the array of
        <li> elements.</li>
        <li>JSX elements don't have to be in an explicit array. You can directly include them as individual elements.
        </li>
        <img src="./assests/images/mapInJSX2.jpg" alt="jsx elements list items">
        <li>Alternatively, you can store the JSX elements in an array, like liArray, and include the array using curly
          braces, like {liArray}.</li>
      </ul>
    </section>

    <section>
      <h2>Keys</h2>
      <ul>
        <li>Keys are JSX attributes used to uniquely identify elements in a list.</li>
        <li>Keys are necessary when you have a list where the items need to maintain their memory or when the order of
          the list might be shuffled between renders.</li>
        <img src="./assests/images/keys.jpg" alt="keys">
        <li>Keys are not used for any visible effects in the rendered output. They are used internally by React to
          optimize list rendering and ensure correct item ordering.</li>
        <li>If you omit keys when they are required, React may mistakenly reorder the list items or cause other issues.
        </li>
        <li>If your list items don't have memory or the list order is static, you may not need to use keys. However,
          it's generally recommended to use keys if you're unsure or if your list might have dynamic changes.</li>
        <li>Using unique and stable values as keys, such as IDs or unique identifiers from data, is recommended to
          ensure consistent behavior and performance in React.</li>
        <img src="./assests/images/mapUniqueKey.jpg" alt="using map to create unique keys">
        <li>In the example above, we're using the .map() method in order to help us create unique keys</li>
      </ul>
    </section>

    <section>
      <h2>React.createElement</h2>
      <ul>
        <li>JSX is a popular syntax extension for writing React code, but it is possible to write React code without
          JSX.</li>
        <img src="./assests/images/reactElement.jpg" alt="react element">
        <li>JSX elements are compiled into calls to React.createElement().</li>
        <li>The React.createElement() method takes three arguments: the element type, the element's properties (or
          "props"), and the element's children.</li>
        <img src="./assests/images/reactCreateElement.jpg" alt="react createElement">
        <li>The first argument of React.createElement() is the type of the element, in this case, the string "h1".</li>
        <li>The second argument is an object representing the element's properties or attributes. Since no properties
          are specified in the example (null is passed), it is equivalent to providing an empty object {} in JSX.</li>
        <li>The third argument is the children of the element, in this case, the string "Hello world".</li>
        <li>React.createElement() returns a React element that can be rendered in a React component.</li>
      </ul>
    </section>

    <h2>React Components</h2>

    <section>
      <h2>Components</h2>
      <ul>
        <li>React applications are built using components.</li>
        <li>A component is a small, reusable piece of code that has a specific responsibility.</li>
        <li>Components are responsible for rendering HTML and updating it when data changes.</li>
        <li>Components can be created using the React library, which is imported at the beginning of the code: import
          React from 'react';</li>
        <li>The React library provides the necessary functions and utilities for creating and working with components in
          React applications.</li>
        <img src="./assests/images/components.jpg" alt="components">
      </ul>
    </section>

    <section>
      <h2>Import React</h2>
      <ul>
        <li>To use React and its features in your code, you need to import it first.</li>
        <img src="./assests/images/importReact.jpg" alt="import react">
        <li>The import statement import React from 'react'; imports the React library and assigns it to an object named
          React.
        </li>
        <li>This import statement should be placed at the beginning of your code file before using any React-related
          features.</li>
        <li>The 'react' string in the import statement refers to the name of the package/module that contains the React
          library.</li>
        <li>Make sure you have the 'react' package installed as a dependency in your project for the import to work
          correctly.</li>
        <li>Importing React allows you to access and use various features and functionalities provided by the React
          library, such as creating and working with components, using hooks, and more.</li>
        <li>It's important to import React in every file where you want to use React components or features.</li>
      </ul>
    </section>

    <section>
      <h2>Import ReactDOM</h2>
      <ul>
        <li>In addition to importing React, we also need to import ReactDOM to interact with the DOM.</li>
        <img src="./assests/images/importReactDOM.jpg" alt="import ReactDOM">
        <li>The import statement import ReactDOM from 'react-dom'; imports the ReactDOM library and assigns it to an
          object named ReactDOM.</li>
        <li>The 'react-dom' string in the import statement refers to the name of the package/module that contains the
          ReactDOM library.</li>
        <li>ReactDOM provides methods that specifically deal with interacting with the DOM, such as rendering React
          components into the browser's DOM.</li>
        <li>Methods imported from 'react' are focused on React-specific functionality and are not directly related to
          manipulating the DOM.</li>
        <li>While React allows us to create and manage components, ReactDOM provides the means to render those
          components into the actual DOM elements of a web page.</li>
        <li>Make sure you have the 'react-dom' package installed as a dependency in your project for the import to work
          correctly.</li>
        <li>Importing ReactDOM is necessary if you want to render React components into the DOM and interact with the
          browser's DOM elements.</li>
      </ul>
    </section>

    <section>
      <h2>Create a Function Component</h2>
      <ul>
        <li>React components are small, reusable chunks of code responsible for rendering HTML and updating it when data
          changes.</li>
        <li>Components are like building blocks that make up a React application, representing different parts of the
          interface.</li>
        <li>Function components are a way to define React components using JavaScript functions.</li>
        <li>Function components have become the standard in modern React applications, replacing class components with
          the introduction of Hooks.</li>
        <img src="./assests/images/functionComponent.jpg" alt="function component">
        <li>Function components can be defined by creating a JavaScript function with a name that represents the
          component.</li>
        <li>Inside the function, a return statement is used to return a React element in JSX syntax, which represents
          the HTML to be rendered.</li>
        <li>The example code shows the definition of a function component named MyComponent that returns an < h1>
            element
            with a specific message.</li>
        <li>The import React from 'react'; statement is used to import the necessary React library.</li>
        <li>The function component is exported using export default so it can be used elsewhere in the application.</li>
      </ul>
    </section>

    <section>
      <h2>Name a Functional Component</h2>
      <ul>
        <li>When declaring a new functional component, it should be given a name.</li>
        <img src="./assests/images/functionalComponentNaming.jpg" alt="functional component naming">
        <li>The name of a functional component should start with a capital letter and follow the convention of
          PascalCase.</li>
        <li>Starting the name with capitalization distinguishes it as a React component rather than an HTML tag.</li>
        <li>This capitalization rule is specific to React and is important to ensure that the component is interpreted
          correctly by React.</li>
      </ul>
    </section>

    <section>
      <h2>Functional Component Instructions</h2>
      <ul>
        <li>In app.js:</li>
        <img src="./assests/images/functionalComponentInstructions.jpg" alt="app.js">
        <li>Importing React from 'react' creates a JavaScript object containing necessary properties for React.</li>
        <li>Defining a JavaScript function creates a function component, which acts as a factory for producing instances
          of itself.</li>
        <li>The function component needs a name written in Pascal case, such as UpperCamelCase.</li>
        <li>The body of the function component, enclosed in curly braces, contains instructions for building a React
          component. It can be seen as JSX code.</li>
        <li> The JSX code inside the return statement of the function component acts as the instructions for building a
          React component.</li>
        <li>Remember, the function component is responsible for rendering HTML and defining the structure and behavior
          of the React component it represents.</li>
        <li>In index.js:</li>
        <img src="./assests/images/functionalComponentInstructionsIndexJS.jpg" alt="index.js">
        <li>Importing ReactDOM from 'react-dom/client' creates a JavaScript object with methods for interacting with the
          DOM, such as ReactDOM.createRoot().</li>
      </ul>
    </section>

    <section>
      <h2>The Return Keyword in Functional Components</h2>
      <ul>
        <li>Functional components in React are similar to regular JavaScript functions and act as factories that
          assemble portions of the user interface based on provided instructions.</li>
        <li>The instructions for a functional component are defined within the function body, delimited by curly braces.
        </li>
        <img src="./assests/images/functionalComponentBody.jpg" alt="functional component body">
        <li>The instructions can include a combination of markup (JSX), CSS, and JavaScript to produce the desired
          result.</li>
        <img src="./assests/images/functionalComponentReturnKeyword.jpg" alt="return keyword in a functional component">
        <li>It is essential to include a return statement in the function body, as the function is expected to return a
          JSX element that can be rendered onto the browser screen.</li>
        <li>The returned JSX element represents the output of the functional component and determines what will be
          displayed.</li>
        <li>Remember, defining a functional component and providing the necessary instructions is only the first step.
          To actually render the component onto the browser screen, it needs to be used or referenced in another part of
          the application.</li>
      </ul>
    </section>

    <section>
      <h2>Importing & Exporting React Components</h2>
      <ul>
        <li>In a React application, the top-level file is usually named App.js, and the entry point is index.js.</li>
        <li>Components can be defined in separate files for organization and reusability.</li>
        <li>To make a component available for use in other files, it needs to be exported.</li>
        <img src="./assests/images/exportFunction.jpg" alt="export function">
        <li>Exporting a component is done by using the export default syntax followed by the component name.</li>
        <li>In the file where the component will be used (e.g., index.js), it can be imported using the import statement
          and specifying the file path.</li>
        <img src="./assests/images/importFunction.jpg" alt="import function">
        <li>Once imported, the component can be used and rendered in the desired location within the file.</li>
        <li>By exporting and importing components, we can create a modular structure in our React application and easily
          reuse components across different files.</li>
      </ul>
    </section>

    <section>
      <h2>Using & Rendering a Component</h2>
      <ul>
        <li>To use a function component, we can treat it like an HTML tag and include it in our JSX code.</li>
        <img src="./assests/images/selfClosingSyntax.jpg" alt="self closing syntax">
        <li>The self-closing tag syntax
          <MyComponent /> can be used to include the component.
        </li>
        <img src="./assests/images/nestedSyntax.jpg" alt="nested syntax">
        <li>If needed, components can be nested within opening and closing tags, like <MyComponent>
            <OtherComponent />
          </MyComponent>.</li>
        <li>To render our component to the browser, we need to use the methods from the react-dom library in the entry
          point file (e.g., index.js).</li>
        <img src="./assests/images/reactDOM.jpg" alt="reactDOM">
        <li>First, we call ReactDOM.createRoot() and pass it a DOM element where the component will be rendered.</li>
        <li>The createRoot() method creates a root container for the DOM element and returns a reference to the root.
        </li>
        <img src="./assests/images/render.jpg" alt="render">
        <li>Finally, we call the .render() method on the root container and pass the component as JSX syntax to display
          it in the DOM.</li>
        <li>React will take over managing the DOM inside the specified root element, and any updates to the UI will be
          handled efficiently by React.</li>
        <li>By using createRoot() and render(), we can set up the initial rendering of our component in the specified
          DOM element and allow React to manage the UI updates from that point onwards.</li>
      </ul>
    </section>

    <section>
      <h2>Review: React Components</h2>
      <ul>
        <li>React applications are made up of components.</li>
        <li>Components are responsible for rendering pieces of the user interface.</li>
        <li>To create components and render them, react and reactDOM must be imported.</li>
        <li>React components can be defined with Javascript functions to make function components.</li>
        <li>Function component names must start with a capitalized letter, and Pascal case is the adopted naming
          convention.</li>
        <li>Function components must return some React elements in JSX syntax.</li>
        <li>React components can be exported and imported from file to file.</li>
        <li>A React component can be used by calling the component name in an HTML-like self-closing tag syntax.</li>
        <li>Rendering a React component requires using .createRoot() to specify a root container and calling the
          .render() method on it.</li>
        <li></li>
      </ul>
      <p>
        <a href="https://www.codecademy.com/learn/learn-react-introduction/modules/learn-react-components/cheatsheet">Codecademy
          -
          Components Cheatsheet</a>
      </p>
    </section>

    <h2>Components & Advanced JSX</h2>

    <section>
      <h2>Use Multiline JSX in a Component</h2>
      <ul>
        <li>When working with multi-line JSX expressions, it is recommended to wrap them in parentheses.</li>
        <li>This is important to ensure the proper interpretation of the JSX syntax and maintain clarity in the code.
        </li>
        <img src="./assests/images/multilineJSXComponent.jpg" alt="multiline JSX in a component">
        <li>In the given example, the QuoteMaker component returns a multi-line JSX expression representing the HTML
          structure of a quote.</li>
        <li>The entire JSX expression is wrapped in parentheses to indicate that it is a single expression.</li>
        <li>The use of parentheses helps in maintaining readability and avoiding any potential syntax errors when
          dealing with multi-line JSX.</li>
      </ul>
    </section>

    <section>
      <h2>Use a Variable Attribute in a Component</h2>
      <ul>
        <li>To render a React component with an image and its properties, we can use a JavaScript object to store the
          image information.</li>
        <img src="./assests/images/variableAttributeinaComponent.jpg" alt="variable attribute in a component">
        <li>Use JSX syntax to render the image using the img element.</li>
        <li>Inject JavaScript code inside curly braces to set attribute values dynamically.</li>
        <li>Use the object's properties to set the image source, alt text, and width.</li>
        <li>JavaScript injections inside the return statement enable dynamic rendering in JSX.</li>
      </ul>
    </section>

    <section>
      <h2>Putting Logic in a Function Component</h2>
      <ul>
        <li>Function components can include logic and calculations.</li>
        <img src="./assests/images/loginInaFunctionalComponent.jpg" alt="functional component with logic">
        <li>By placing the calculations before the return statement, you can perform operations and store the result in
          variables.</li>
        <li>These calculations can involve any JavaScript code, such as mathematical operations, conditionals, or
          function calls.</li>
        <li>The calculated value can then be used within the JSX element by injecting the variable using curly braces.
        </li>
        <li>It is important to ensure that the logic and calculations are placed before the return statement in the
          function component.</li>
        <img src="./assests/images/incorrectLogicInaFunctionalComponent.jpg"
          alt="incorect logic in a functional component">
        <li>Placing logic within the return statement directly, without proper syntax, will result in a syntax error.
        </li>
      </ul>
    </section>

    <section>
      <h2>Event Listener & Event Handlers in a Component</h2>
      <ul>
        <li>Function components can include event handlers to respond to interactions with the interface, such as
          clicking or hovering.</li>
        <li>Event handlers are functions that define the logic for what should happen when an event occurs.</li>
        <img src="./assests/images/eventHandlerComponent.jpg" alt="event handler">
        <li>Event handlers are defined inside the function component and typically start with the word "handle" followed
          by the type of event they are handling.</li>
        <li>Event handlers are passed as props to JSX elements.</li>
        <img src="./assests/images/eventHandlerComponentwithNoParenthesis.jpg" alt="event handler with no parenthesis">
        <li>When passing an event handler, do not include the parentheses after the function name. This ensures that the
          function is called only when the event occurs, rather than immediately.</li>
      </ul>
    </section>

    <section>
      <h2>Review: Components & Advanced JSX</h2>
      <ul>
        <li>Function components can return multiple JSX lines by nesting the elements in a parent element.</li>
        <li>Variable attributes can be used inside of a React component with JavaScript injections.</li>
        <li>React components support logic by putting the logic statements above the return statements. </li>
        <li>Components can conditionally return JSX elements by putting conditional statements inside of the components.
        </li>
        <li>Components can respond to events by defining event handlers and passing them to the JSX elements.</li>
      </ul>
    </section>

    <h2>Components Render Other Components</h2>

    <section>
      <h2>Returning Another Component</h2>
      <ul>
        <li>Components in React can interact with each other by passing information or returning other components.</li>
        <li>A component can return another component as part of its JSX structure.</li>
        <img src="./assests/images/returningAnotherComponent.jpg" alt="Returning Another Component">
        <li>By returning another component, you can compose your UI by combining multiple components together.</li>
        <li>In the example provided, the ItemBox component returns an instance of the PurchaseButton component, allowing
          them to be rendered together.</li>
      </ul>
    </section>

    <section>
      <h2>Apply a Component in a Render Function</h2>
      <ul>
        <li>Components can be applied in a render function by importing them into the file.</li>
        <li>In the top-level file (e.g., App.js), import the desired component using the appropriate path.</li>
        <img src="./assests/images/componentInRenderFunction.jpg" alt="component in render function">
        <li>Inside the render function (e.g., App component), use the imported component as a JSX element.</li>
        <li>The imported component can be considered a child component of the parent component.</li>
        <li>Breaking a component into smaller extracted components allows for reusability and the construction of more
          complex components.</li>
      </ul>
    </section>

    <section>
      <h2>Review: Components Render Other Components</h2>
      <ul>
        <li>A React application can contain multiple components.</li>
        <li>Components can interact with each other by returning instances of each other. </li>
        <li>Components interacting allows them to be broken into smaller components, stored into separate files, and
          reused when necessary.</li>
      </ul>
    </section>

    <h2>Props</h2>

    <section>
      <h2>Props</h2>
      <ul>
        <li>Components in React can communicate with each other by passing information through props.</li>
        <li>Props allow customization of the output of a component based on the information that is passed in.</li>
        <li>Props provide a way to pass data from a parent component to a child component.</li>
        <li>By using props, components can become more flexible and dynamic in their behavior.</li>
        <li>Props enable components to be reusable and adaptable in different contexts.</li>
      </ul>
    </section>

    <section>
      <h2>Access a Components Props</h2>
      <ul>
        <li>Every component in React has a props object that holds information about that component.</li>
        <li>Props allow us to pass information from a parent component to a child component.</li>
        <li>Props serve a similar purpose as arguments in functions.</li>
        <img src="./assests/images/accessingProps.jpg" alt="accessing props">
        <li>To access a component's props, we can use dot notation and reference the specific property we want to
          access.</li>
        <li>We can use props to customize the behavior and output of components based on the information passed to them.
        </li>
      </ul>
    </section>

    <section>
      <h2>Pass 'props' to a Component</h2>
      <ul>
        <li>To pass information (props) to a React component, you give the component an attribute.</li>
        <li>The attribute name represents the name of the prop you want to pass, and the attribute value represents the
          value of that prop.</li>
        <img src="./assests/images/componentAttribute.jpg" alt="component attribute">
        <li>Props can hold any type of information, including strings, numbers, booleans, and even arrays or objects.
        </li>
        <li>If you want to pass a non-string value as a prop, you need to wrap it in curly braces.</li>
        <img src="./assests/images/nonStringProps.jpg" alt="non string props">
      </ul>
    </section>

    <section>
      <h2>Render a Components Props</h2>
      <ul>
        <li>To access the props object inside a function component, define the component with props as the parameter.
        </li>
        <img src="./assests/images/propsParameter.jpg" alt="props parameter">
        <li>The props object contains the information passed to the component.</li>
        <li>You can access the values of props using dot notation (props.propertyName).</li>
        <img src="./assests/images/destructuresProps.jpg" alt="destructured props">
        <li>Alternatively, you can use destructuring syntax to extract specific props values directly in the function
          signature. For example, function Button({displayText}) extracts the displayText prop from the props object.
        </li>
        <li>Inside the component's return statement, you can use the props values to render the desired output.</li>
      </ul>
    </section>

    <section>
      <h2>Pass Props from Component to Component</h2>
      <ul>
        <li>Props in React are passed from parent components to child components.</li>
        <img src="./assests/images/parentPassingPropsToChildComponent.jpg"
          alt="parent passing props to child component">
        <li>The parent component defines the props and passes them to the child component.</li>
        <li>Props are immutable, meaning they cannot be changed by the child component.</li>
        <li>If a component needs new values for its props, it should rely on the parent component to pass new props.
        </li>
        <li>Props travel in a one-way direction, from the top (parent) component to the bottom (child) component.</li>
      </ul>
    </section>

    <section>
      <h2>Render Different UI Based on Props</h2>
      <ul>
        <li>Props can be used to make decisions and render different UI based on the values they hold.</li>
        <li>Instead of directly displaying the prop value, you can use it to conditionally render different components
          or content.</li>
        <li>By using conditional statements like if and else, you can check the prop values and return different JSX
          elements based on the conditions.</li>
        <img src="./assests/images/conditionalProp.jpg" alt="conditional prop">
        <li>This allows you to customize the rendering of a component based on the values passed through props.</li>
        <li>The prop values themselves are not displayed, but they are used to determine the output.</li>
      </ul>
    </section>

    <section>
      <h2>Put an Event Handler in a Function Component</h2>
      <ul>
        <li>Event handlers in React are defined as methods on the function component.</li>
        <li>To define an event handler, you create a function within the function component.</li>
        <img src="./assests/images/eventHandler.jpg" alt="event handler">
        <li>In the example, the event handler method is defined as handleEvent().</li>
        <li>The event handler is attached to an event, such as a click event, using the onClick attribute.</li>
        <li>In this case, the event handler handleEvent is attached to the onClick event.</li>
        <li>When the element is clicked, the event handler function will be called.</li>
        <li>Inside the event handler, you can define the desired behavior or action to be performed, such as displaying
          an alert message.</li>
        <li>Event handlers allow you to respond to user interactions and perform actions based on those interactions.
        </li>
      </ul>
    </section>

    <section>
      <h2>handleEvent, onEvent, and props.onEvent</h2>
      <ul>
        <li>When defining an event handler, you need to choose two names: the name of the event handler function itself
          and the name of the prop used to pass the event handler.</li>
        <img src="./assests/images/handleEventNaming.jpg" alt="handleEvent naming">
        <li>The event handler function's name follows a naming convention based on the type of event you are listening
          for. For example, if you are listening for a "click" event, you can name your event handler function as
          handleClick. If you are listening for a "hover" event, you can name it as handleHover.</li>
        <img src="./assests/images/propNaming.jpg" alt="prop naming">
        <li>The prop name that is used to pass the event handler follows the pattern of "on" plus the event type. For
          example, if you are listening for a "click" event, the prop name can be onClick. If you are listening for a
          "hover" event, the prop name can be onHover.</li>
        <li>By following this naming convention, it becomes easier to understand the purpose and functionality of the
          event handler and the prop.</li>
        <li>Using consistent naming conventions improves code readability and makes it easier to understand the flow of
          data and interactions between components.</li>
      </ul>
    </section>

    <section>
      <h2>props.children</h2>
      <ul>
        <li>The props.children property returns everything that is passed between the opening and closing tags of a
          component.</li>
        <li>It allows components to have dynamic content and makes them flexible and reusable.</li>
        <img src="./assests/images/noChildProp.jpg" alt="component with no children">
        <li>When a component has no children, props.children will be undefined.</li>
        <img src="./assests/images/singleChildProp.jpg" alt="component with a single child">
        <li>If a component has a single child, props.children will return that child without being wrapped in an array.
        </li>
        <img src="./assests/images/multiChildProp.jpg" alt="component with multiple children">
        <li>If a component has multiple children, props.children will return an array containing all the children.</li>
        <li>This allows components to handle different content and structures based on what is passed to them as
          children.</li>
        <li>The value of props.children can be text, other components, or a combination of both.</li>
        <li>By utilizing props.children, components can be composed and structured in a more flexible and customizable
          way.</li>
      </ul>
    </section>

    <section>
      <h2>Giving Default Values to Props</h2>
      <ul>
        <li>When working with React components, you may encounter situations where a prop is not passed, and you want to
          provide a default value for it.</li>
        <li>There are three ways to specify default values for props:</li>
        <img src="./assests/images/defaultPropStaticProperty.jpg" alt="default props static property">
        <li>Using the defaultProps static property: Define a defaultProps property on the component and assign an object
          with the prop name and its default value.</li>
        <img src="./assests/images/defultPropFunctionDefinition.jpg" alt="default prop function definition">
        <li>Specifying the default value in the function definition using destructuring: Include the prop with a default
          value in the function parameter.</li>
        <img src="./assests/images/defaultPropFunctionBody.jpg" alt="default prop function body">
        <li>Setting the default value within the function body: Destructure the prop and assign a default value using
          the assignment operator.</li>
        <li>If no value is passed for the prop, the default value will be used.</li>
        <li>If a value is passed for the prop, it will override the default value and be displayed instead.</li>
      </ul>
    </section>

    <section>
      <h2></h2>
      <ul>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
      </ul>
    </section>

    <section>
      <h2></h2>
      <ul>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
      </ul>
    </section>

  </main>

</body>

</html>
